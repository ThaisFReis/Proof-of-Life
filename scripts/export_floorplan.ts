#!/usr/bin/env bun
/**
 * Export floorplan from TypeScript frontend to Rust contract.
 * 
 * This script reads the floorplan definition from the frontend and generates
 * a Rust module with compact bitset representations for on-chain storage.
 */

import { readFileSync, writeFileSync } from 'fs';
import { createHash } from 'crypto';
import { join } from 'path';

// Import floorplan data from frontend
const frontendPath = join(import.meta.dir, '../proof-of-life-frontend/src/games/proof-of-life/world/floorplan.ts');
const contractPath = join(import.meta.dir, '../contracts/proof-of-life/src/floorplan.rs');

// Read and evaluate the frontend floorplan
const frontendCode = readFileSync(frontendPath, 'utf-8');

// Extract constants using regex (simple approach for this use case)
const BOARD_W = 10;
const BOARD_H = 10;

// Extract BLOCKED_TILES
const blockedTilesMatch = frontendCode.match(/export const BLOCKED_TILES: readonly BlockedTile\[\] = \[([\s\S]*?)\] as const;/);
const blockedTiles: { x: number; y: number }[] = [];
if (blockedTilesMatch) {
  const content = blockedTilesMatch[1];
  const matches = content.matchAll(/\{\s*x:\s*(\d+),\s*y:\s*(\d+)/g);
  for (const match of matches) {
    blockedTiles.push({ x: parseInt(match[1]), y: parseInt(match[2]) });
  }
}

// Extract HIDE_TILES
const hideTilesMatch = frontendCode.match(/export const HIDE_TILES: Readonly<Record<RoomCode, readonly HideTile\[\]\>> = \{([\s\S]*?)\} as const;/);
const hideTiles: { x: number; y: number }[] = [];
if (hideTilesMatch) {
  const content = hideTilesMatch[1];
  const matches = content.matchAll(/\{\s*x:\s*(\d+),\s*y:\s*(\d+)/g);
  for (const match of matches) {
    hideTiles.push({ x: parseInt(match[1]), y: parseInt(match[2]) });
  }
}

// Extract DOORS_OPEN
const doorsOpenMatch = frontendCode.match(/export const DOORS_OPEN: readonly DoorEdge\[\] = \[([\s\S]*?)\] as const;/);
const doorsOpen: { ax: number; ay: number; bx: number; by: number }[] = [];
if (doorsOpenMatch) {
  const content = doorsOpenMatch[1];
  const matches = content.matchAll(/\{\s*ax:\s*(\d+),\s*ay:\s*(\d+),\s*bx:\s*(\d+),\s*by:\s*(\d+)/g);
  for (const match of matches) {
    doorsOpen.push({
      ax: parseInt(match[1]),
      ay: parseInt(match[2]),
      bx: parseInt(match[3]),
      by: parseInt(match[4]),
    });
  }
}

// Extract ROOM_GRID
const roomGridMatch = frontendCode.match(/export const ROOM_GRID: readonly string\[\] = \[([\s\S]*?)\] as const;/);
const roomGrid: string[] = [];
if (roomGridMatch) {
  const content = roomGridMatch[1];
  // Match each string line individually
  const lines = content.split('\n').filter(line => line.trim().startsWith("'"));
  for (const line of lines) {
    const match = line.match(/'([A-Z]+)'/);
    if (match) {
      roomGrid.push(match[1]);
    }
  }
}

// Convert to bitsets
function toBitset(tiles: { x: number; y: number }[]): number[] {
  const bitset = new Array(BOARD_H).fill(0);
  for (const tile of tiles) {
    bitset[tile.y] |= 1 << tile.x;
  }
  return bitset;
}

const blockedBitset = toBitset(blockedTiles);
const hideBitset = toBitset(hideTiles);

// Compute checksum
function computeChecksum(): string {
  const hash = createHash('sha256');
  hash.update(JSON.stringify({ blockedTiles, hideTiles, doorsOpen, roomGrid }));
  return hash.digest('hex').substring(0, 8);
}

const checksum = computeChecksum();

// Generate Rust code
const rustCode = `//! Floorplan constants for Proof of Life
//!
//! This file is AUTO-GENERATED by scripts/export_floorplan.ts
//! DO NOT EDIT MANUALLY - changes will be overwritten
//!
//! Checksum: ${checksum}

pub const BOARD_W: u32 = ${BOARD_W};
pub const BOARD_H: u32 = ${BOARD_H};

/// Checksum of floorplan data (for sync verification)
pub const FLOORPLAN_CHECKSUM: &str = "${checksum}";

/// Blocked tiles bitset (10 rows, each u32 represents a row with bits for columns)
/// Bit N in row Y is set if tile (N, Y) is blocked
pub const BLOCKED_TILES: [u32; ${BOARD_H}] = [
${blockedBitset.map(b => `    ${b},`).join('\n')}
];

/// Hide tiles bitset (10 rows, each u32 represents a row with bits for columns)
/// Bit N in row Y is set if tile (N, Y) is a hide tile
pub const HIDE_TILES: [u32; ${BOARD_H}] = [
${hideBitset.map(b => `    ${b},`).join('\n')}
];

/// Room grid (10x10, each char is a room code)
/// G=Garden, H=Hallway, L=Living, S=Study, B=Library, D=Dining, E=Entrance, K=Kitchen, W=Winter
pub const ROOM_GRID: [[u8; ${BOARD_W}]; ${BOARD_H}] = [
${roomGrid.map(row => `    [${row.split('').map(c => `b'${c}'`).join(', ')}],`).join('\n')}
];

/// Open doors (edges that connect rooms)
pub const DOORS_OPEN: [(u32, u32, u32, u32); ${doorsOpen.length}] = [
${doorsOpen.map(d => `    (${d.ax}, ${d.ay}, ${d.bx}, ${d.by}),`).join('\n')}
];

/// Check if coordinates are in bounds
pub fn in_bounds(x: u32, y: u32) -> bool {
    x < BOARD_W && y < BOARD_H
}

/// Check if a tile is blocked (inaccessible)
pub fn is_blocked_tile(x: u32, y: u32) -> bool {
    if !in_bounds(x, y) {
        return true;
    }
    let row = BLOCKED_TILES[y as usize];
    (row & (1 << x)) != 0
}

/// Check if a tile is a hide tile
pub fn is_hide_tile(x: u32, y: u32) -> bool {
    if !in_bounds(x, y) {
        return false;
    }
    let row = HIDE_TILES[y as usize];
    (row & (1 << x)) != 0
}

/// Check if position is within manhattan distance <= 2 of any hide tile
pub fn is_within_hide_range(x: u32, y: u32) -> bool {
    if !in_bounds(x, y) {
        return false;
    }
    
    // Check all tiles within manhattan distance 2
    for dy in 0..=2 {
        for dx in 0..=(2 - dy) {
            // Check all 4 quadrants
            let positions = [
                (x.wrapping_add(dx), y.wrapping_add(dy)),
                (x.wrapping_sub(dx), y.wrapping_add(dy)),
                (x.wrapping_add(dx), y.wrapping_sub(dy)),
                (x.wrapping_sub(dx), y.wrapping_sub(dy)),
            ];
            
            for (nx, ny) in positions {
                if in_bounds(nx, ny) && is_hide_tile(nx, ny) {
                    return true;
                }
            }
        }
    }
    
    false
}

/// Get room code at position
pub fn get_room_code(x: u32, y: u32) -> u8 {
    if !in_bounds(x, y) {
        return b'H'; // Default to hallway
    }
    ROOM_GRID[y as usize][x as usize]
}

/// Check if two adjacent cells are connected (no wall between them)
fn are_connected(ax: u32, ay: u32, bx: u32, by: u32) -> bool {
    // Check if there's a door connecting these cells
    for &(dx1, dy1, dx2, dy2) in &DOORS_OPEN {
        if (dx1 == ax && dy1 == ay && dx2 == bx && dy2 == by)
            || (dx1 == bx && dy1 == by && dx2 == ax && dy2 == ay)
        {
            return true;
        }
    }
    
    // If same room and no wall between, they're connected
    if in_bounds(ax, ay) && in_bounds(bx, by) {
        let room_a = get_room_code(ax, ay);
        let room_b = get_room_code(bx, by);
        if room_a == room_b {
            return true;
        }
    }
    
    false
}

/// Check if 4-directional movement is valid
pub fn can_move4(ax: u32, ay: u32, bx: u32, by: u32) -> bool {
    // Must be in bounds
    if !in_bounds(ax, ay) || !in_bounds(bx, by) {
        return false;
    }
    
    // Must not be blocked
    if is_blocked_tile(ax, ay) || is_blocked_tile(bx, by) {
        return false;
    }
    
    // Must be adjacent (manhattan distance 1)
    let dx = if bx > ax { bx - ax } else { ax - bx };
    let dy = if by > ay { by - ay } else { ay - by };
    if dx + dy != 1 {
        return false; // Not adjacent or diagonal
    }
    
    // Must be connected (no wall or has door)
    are_connected(ax, ay, bx, by)
}
`;

// Write Rust file
writeFileSync(contractPath, rustCode, 'utf-8');

console.log(`✅ Generated ${contractPath}`);
console.log(`   Checksum: ${checksum}`);
console.log(`   Blocked tiles: ${blockedTiles.length}`);
console.log(`   Hide tiles: ${hideTiles.length}`);
console.log(`   Doors: ${doorsOpen.length}`);

// Update frontend with checksum comment
const updatedFrontendCode = frontendCode.replace(
  /(export const BOARD_W = 10;)/,
  `// Floorplan checksum: ${checksum} (auto-generated, do not edit)\n$1`
);

if (updatedFrontendCode !== frontendCode) {
  writeFileSync(frontendPath, updatedFrontendCode, 'utf-8');
  console.log(`✅ Updated ${frontendPath} with checksum`);
}

console.log('\n✨ Floorplan export complete!');
