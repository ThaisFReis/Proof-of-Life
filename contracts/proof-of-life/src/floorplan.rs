//! Floorplan constants for Proof of Life
//!
//! This file is AUTO-GENERATED by scripts/export_floorplan.ts
//! DO NOT EDIT MANUALLY - changes will be overwritten
//!
//! Checksum: 9e73b691

pub const BOARD_W: u32 = 10;
pub const BOARD_H: u32 = 10;

/// Checksum of floorplan data (for sync verification)
pub const FLOORPLAN_CHECKSUM: &str = "9e73b691";

/// Blocked tiles bitset (10 rows, each u32 represents a row with bits for columns)
/// Bit N in row Y is set if tile (N, Y) is blocked
pub const BLOCKED_TILES: [u32; 10] = [
    0,
    0,
    96,
    0,
    16,
    16,
    0,
    0,
    0,
    7,
];

/// Hide tiles bitset (10 rows, each u32 represents a row with bits for columns)
/// Bit N in row Y is set if tile (N, Y) is a hide tile
pub const HIDE_TILES: [u32; 10] = [
    256,
    2,
    0,
    513,
    130,
    128,
    545,
    256,
    36,
    520,
];

/// Room grid (10x10, each char is a room code)
/// G=Garden, H=Hallway, L=Living, S=Study, B=Library, D=Dining, E=Entrance, K=Kitchen, W=Winter
pub const ROOM_GRID: [[u8; 10]; 10] = [
    [b'G', b'G', b'G', b'G', b'G', b'G', b'G', b'G', b'G', b'G'],
    [b'G', b'G', b'G', b'G', b'G', b'G', b'G', b'G', b'G', b'G'],
    [b'G', b'G', b'G', b'G', b'G', b'G', b'G', b'G', b'G', b'G'],
    [b'L', b'L', b'L', b'H', b'H', b'H', b'S', b'S', b'S', b'S'],
    [b'L', b'L', b'L', b'H', b'W', b'H', b'S', b'S', b'S', b'S'],
    [b'B', b'B', b'B', b'H', b'W', b'H', b'H', b'D', b'D', b'D'],
    [b'B', b'B', b'B', b'H', b'H', b'H', b'H', b'D', b'D', b'D'],
    [b'B', b'B', b'B', b'E', b'E', b'E', b'H', b'K', b'K', b'K'],
    [b'B', b'B', b'B', b'E', b'E', b'E', b'H', b'K', b'K', b'K'],
    [b'H', b'H', b'H', b'E', b'E', b'E', b'H', b'K', b'K', b'K'],
];

/// Open doors (edges that connect rooms)
pub const DOORS_OPEN: [(u32, u32, u32, u32); 12] = [
    (4, 2, 4, 3),
    (1, 2, 1, 3),
    (2, 4, 2, 5),
    (2, 3, 3, 3),
    (2, 6, 3, 6),
    (2, 7, 3, 7),
    (8, 2, 8, 3),
    (5, 3, 6, 3),
    (7, 6, 7, 7),
    (6, 8, 7, 8),
    (6, 5, 7, 5),
    (4, 6, 4, 7),
];

/// Check if coordinates are in bounds
pub fn in_bounds(x: u32, y: u32) -> bool {
    x < BOARD_W && y < BOARD_H
}

/// Check if a tile is blocked (inaccessible)
pub fn is_blocked_tile(x: u32, y: u32) -> bool {
    if !in_bounds(x, y) {
        return true;
    }
    let row = BLOCKED_TILES[y as usize];
    (row & (1 << x)) != 0
}

/// Check if a tile is a hide tile
pub fn is_hide_tile(x: u32, y: u32) -> bool {
    if !in_bounds(x, y) {
        return false;
    }
    let row = HIDE_TILES[y as usize];
    (row & (1 << x)) != 0
}

/// Check if position is within manhattan distance <= 2 of any hide tile
pub fn is_within_hide_range(x: u32, y: u32) -> bool {
    if !in_bounds(x, y) {
        return false;
    }
    
    // Check all tiles within manhattan distance 2
    for dy in 0..=2 {
        for dx in 0..=(2 - dy) {
            // Check all 4 quadrants
            let positions = [
                (x.wrapping_add(dx), y.wrapping_add(dy)),
                (x.wrapping_sub(dx), y.wrapping_add(dy)),
                (x.wrapping_add(dx), y.wrapping_sub(dy)),
                (x.wrapping_sub(dx), y.wrapping_sub(dy)),
            ];
            
            for (nx, ny) in positions {
                if in_bounds(nx, ny) && is_hide_tile(nx, ny) {
                    return true;
                }
            }
        }
    }
    
    false
}

/// Get room code at position
pub fn get_room_code(x: u32, y: u32) -> u8 {
    if !in_bounds(x, y) {
        return b'H'; // Default to hallway
    }
    ROOM_GRID[y as usize][x as usize]
}

/// Check if two adjacent cells are connected (no wall between them)
fn are_connected(ax: u32, ay: u32, bx: u32, by: u32) -> bool {
    // Check if there's a door connecting these cells
    for &(dx1, dy1, dx2, dy2) in &DOORS_OPEN {
        if (dx1 == ax && dy1 == ay && dx2 == bx && dy2 == by)
            || (dx1 == bx && dy1 == by && dx2 == ax && dy2 == ay)
        {
            return true;
        }
    }
    
    // If same room and no wall between, they're connected
    if in_bounds(ax, ay) && in_bounds(bx, by) {
        let room_a = get_room_code(ax, ay);
        let room_b = get_room_code(bx, by);
        if room_a == room_b {
            return true;
        }
    }
    
    false
}

/// Check if 4-directional movement is valid
pub fn can_move4(ax: u32, ay: u32, bx: u32, by: u32) -> bool {
    // Must be in bounds
    if !in_bounds(ax, ay) || !in_bounds(bx, by) {
        return false;
    }
    
    // Must not be blocked
    if is_blocked_tile(ax, ay) || is_blocked_tile(bx, by) {
        return false;
    }
    
    // Must be adjacent (manhattan distance 1)
    let dx = if bx > ax { bx - ax } else { ax - bx };
    let dy = if by > ay { by - ay } else { ay - by };
    if dx + dy != 1 {
        return false; // Not adjacent or diagonal
    }
    
    // Must be connected (no wall or has door)
    are_connected(ax, ay, bx, by)
}
