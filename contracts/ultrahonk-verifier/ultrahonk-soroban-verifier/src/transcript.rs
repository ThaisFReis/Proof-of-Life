//! Fiatâ€“Shamir transcript for UltraHonk
//!
//! Matches the Solidity reference verifier generated by bb v3.0.0 (evm/evm-no-zk target).
//! Key protocol details:
//!   - splitChallenge: 127-bit numeric split (not 128-bit byte split)
//!   - eta round: includes vk_hash as first element, public inputs, pairing point object,
//!                then w1/w2/w3 as raw (x, y) coordinates
//!   - alpha: single alpha from hash, then alpha^i powers
//!   - gate challenges: first from hash, then gc[i] = gc[i-1]^2
//!   - points serialized as raw (x, y) 32-byte coordinates (no limb splitting)

use crate::{
    field::Fr,
    hash::hash32,
    trace,
    types::{
        G1Point, Proof, RelationParameters, Transcript, CONST_PROOF_SIZE_LOG_N, NUMBER_OF_ALPHAS,
        PAIRING_POINTS_SIZE,
    },
};
use soroban_sdk::{Bytes, Env};

/// Helper: append a [u8; 32] slice to a Bytes buffer.
#[inline(always)]
fn push_32(env: &Env, buf: &mut Bytes, arr: &[u8; 32]) {
    buf.append(&Bytes::from_array(env, arr));
}

/// Push raw G1 point (x, y) as two 32-byte coordinates.
/// Matches Solidity's `abi.encodePacked(pt.x, pt.y)`.
fn push_point(env: &Env, buf: &mut Bytes, pt: &G1Point) {
    push_32(env, buf, &pt.x);
    push_32(env, buf, &pt.y);
}

/// Split a challenge into two 127-bit halves.
/// Matches Solidity: lo = value & 0x7FFF...FFFF (127 bits), hi = value >> 127.
fn split_challenge(challenge: Fr) -> (Fr, Fr) {
    let bytes = challenge.to_bytes(); // big-endian 32 bytes

    // Reconstruct as two u128 halves (big-endian: bytes[0..16] = high, bytes[16..32] = low)
    let val_hi128 = u128::from_be_bytes([
        bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],
        bytes[8], bytes[9], bytes[10], bytes[11], bytes[12], bytes[13], bytes[14], bytes[15],
    ]);
    let val_lo128 = u128::from_be_bytes([
        bytes[16], bytes[17], bytes[18], bytes[19], bytes[20], bytes[21], bytes[22], bytes[23],
        bytes[24], bytes[25], bytes[26], bytes[27], bytes[28], bytes[29], bytes[30], bytes[31],
    ]);

    // lo = bottom 127 bits = val_lo128 & ((1u128 << 127) - 1)
    let lo_val = val_lo128 & ((1u128 << 127) - 1);

    // hi = value >> 127
    // = (val_hi128 * 2^128 + val_lo128) >> 127
    // = (val_hi128 << 1) | (val_lo128 >> 127)
    let hi_val = (val_hi128 << 1) | (val_lo128 >> 127);

    // Convert back to big-endian Fr bytes
    let lo_be = lo_val.to_be_bytes();
    let hi_be = hi_val.to_be_bytes();

    let mut lo_fr_bytes = [0u8; 32];
    lo_fr_bytes[16..].copy_from_slice(&lo_be);

    let mut hi_fr_bytes = [0u8; 32];
    hi_fr_bytes[16..].copy_from_slice(&hi_be);

    (Fr::from_bytes(&lo_fr_bytes), Fr::from_bytes(&hi_fr_bytes))
}

#[inline(always)]
fn hash_to_fr(bytes: &Bytes) -> Fr {
    Fr::from_bytes(&hash32(bytes))
}

/// Generate eta, eta_two, eta_three challenges.
/// Matches Solidity: hash(vk_hash, public_inputs[..], pairing_point_object[..], w1, w2, w3)
fn generate_eta_challenge(
    env: &Env,
    proof: &Proof,
    public_inputs: &Bytes,
    vk_hash: &[u8; 32],
    public_inputs_size: u64,
) -> (Fr, Fr, Fr, Fr) {
    let mut data = Bytes::new(env);

    // 1) VK hash
    push_32(env, &mut data, vk_hash);

    // 2) User public inputs (raw bytes, already 32-byte aligned field elements)
    let user_inputs_count = public_inputs_size - PAIRING_POINTS_SIZE as u64;
    let user_input_bytes = (user_inputs_count as u32) * 32;
    if user_input_bytes > 0 && public_inputs.len() >= user_input_bytes {
        let pi_slice = public_inputs.slice(0..user_input_bytes);
        data.append(&pi_slice);
    }

    // 3) Pairing point object
    for fr in &proof.pairing_point_object {
        push_32(env, &mut data, &fr.to_bytes());
    }

    // 4) w1, w2, w3 as raw (x, y) coordinates
    push_point(env, &mut data, &proof.w1);
    push_point(env, &mut data, &proof.w2);
    push_point(env, &mut data, &proof.w3);

    trace!("[transcript] eta_data len = {}", data.len());
    let previous_challenge = hash_to_fr(&data);
    trace!("[transcript] eta_hash = 0x{}", hex::encode(previous_challenge.to_bytes()));
    let (eta, eta_two) = split_challenge(previous_challenge);
    trace!("[transcript] eta     = 0x{}", hex::encode(eta.to_bytes()));
    trace!("[transcript] eta_two = 0x{}", hex::encode(eta_two.to_bytes()));

    let prev_bytes = Bytes::from_array(env, &previous_challenge.to_bytes());
    let previous_challenge = hash_to_fr(&prev_bytes);
    let (eta_three, _) = split_challenge(previous_challenge);
    trace!("[transcript] eta_three = 0x{}", hex::encode(eta_three.to_bytes()));

    (eta, eta_two, eta_three, previous_challenge)
}

/// Generate beta and gamma.
/// Matches Solidity: hash(prev, lookupReadCounts, lookupReadTags, w4)
fn generate_beta_and_gamma_challenges(
    env: &Env,
    previous_challenge: Fr,
    proof: &Proof,
) -> (Fr, Fr, Fr) {
    let mut data = Bytes::new(env);
    push_32(env, &mut data, &previous_challenge.to_bytes());
    push_point(env, &mut data, &proof.lookup_read_counts);
    push_point(env, &mut data, &proof.lookup_read_tags);
    push_point(env, &mut data, &proof.w4);

    let next_previous_challenge = hash_to_fr(&data);
    let (beta, gamma) = split_challenge(next_previous_challenge);
    trace!("[transcript] beta  = 0x{}", hex::encode(beta.to_bytes()));
    trace!("[transcript] gamma = 0x{}", hex::encode(gamma.to_bytes()));
    (beta, gamma, next_previous_challenge)
}

/// Generate alpha challenges.
/// Matches Solidity: hash(prev, lookupInverses, zPerm) -> alpha, then alphas[i] = alpha^(i+1)
fn generate_alpha_challenges(
    env: &Env,
    previous_challenge: Fr,
    proof: &Proof,
) -> ([Fr; NUMBER_OF_ALPHAS], Fr) {
    let mut data = Bytes::new(env);
    push_32(env, &mut data, &previous_challenge.to_bytes());
    push_point(env, &mut data, &proof.lookup_inverses);
    push_point(env, &mut data, &proof.z_perm);

    let next_previous_challenge = hash_to_fr(&data);
    let (alpha, _) = split_challenge(next_previous_challenge);
    trace!("[transcript] alpha = 0x{}", hex::encode(alpha.to_bytes()));

    // Powers of alpha: alphas[0] = alpha, alphas[i] = alphas[i-1] * alpha
    let mut alphas = [Fr::zero(); NUMBER_OF_ALPHAS];
    alphas[0] = alpha;
    for i in 1..NUMBER_OF_ALPHAS {
        alphas[i] = alphas[i - 1] * alpha;
    }

    (alphas, next_previous_challenge)
}

/// Generate gate challenges.
/// Matches Solidity: gc[0] = split(hash(prev)). Then gc[i] = gc[i-1]^2 for i > 0.
fn generate_gate_challenges(
    env: &Env,
    previous_challenge: Fr,
) -> ([Fr; CONST_PROOF_SIZE_LOG_N], Fr) {
    let prev_bytes = Bytes::from_array(env, &previous_challenge.to_bytes());
    let next_previous_challenge = hash_to_fr(&prev_bytes);
    let (gc0, _) = split_challenge(next_previous_challenge);
    trace!("[transcript] gate_challenge[0] = 0x{}", hex::encode(gc0.to_bytes()));

    let mut gate_challenges = [Fr::zero(); CONST_PROOF_SIZE_LOG_N];
    gate_challenges[0] = gc0;
    for i in 1..CONST_PROOF_SIZE_LOG_N {
        gate_challenges[i] = gate_challenges[i - 1] * gate_challenges[i - 1]; // squaring
    }

    (gate_challenges, next_previous_challenge)
}

/// Generate sumcheck challenges.
/// Matches Solidity: for each round, hash(prev, univariate[0..BPL])
fn generate_sumcheck_challenges(
    env: &Env,
    proof: &Proof,
    previous_challenge: Fr,
    log_n: usize,
) -> ([Fr; CONST_PROOF_SIZE_LOG_N], Fr) {
    let mut next_previous_challenge = previous_challenge;
    let mut sumcheck_challenges = [Fr::zero(); CONST_PROOF_SIZE_LOG_N];
    for r in 0..log_n {
        let mut data = Bytes::new(env);
        push_32(env, &mut data, &next_previous_challenge.to_bytes());
        for &c in proof.sumcheck_univariates[r].iter() {
            push_32(env, &mut data, &c.to_bytes());
        }
        next_previous_challenge = hash_to_fr(&data);
        sumcheck_challenges[r] = split_challenge(next_previous_challenge).0;
        trace!(
            "[transcript] sumcheck_u[{}] = 0x{}",
            r,
            hex::encode(sumcheck_challenges[r].to_bytes())
        );
    }
    (sumcheck_challenges, next_previous_challenge)
}

/// Generate rho challenge.
/// Matches Solidity: hash(prev, sumcheck_evaluations[0..NUMBER_OF_ENTITIES])
fn generate_rho_challenge(env: &Env, proof: &Proof, previous_challenge: Fr) -> (Fr, Fr) {
    let mut data = Bytes::new(env);
    push_32(env, &mut data, &previous_challenge.to_bytes());
    for &e in proof.sumcheck_evaluations.iter() {
        push_32(env, &mut data, &e.to_bytes());
    }
    let next_previous_challenge = hash_to_fr(&data);
    let rho = split_challenge(next_previous_challenge).0;
    (rho, next_previous_challenge)
}

/// Generate gemini_r challenge.
/// Matches Solidity: hash(prev, geminiFoldComms[0..logN-1] as raw x,y)
fn generate_gemini_r_challenge(
    env: &Env, proof: &Proof, previous_challenge: Fr, log_n: usize,
) -> (Fr, Fr) {
    let mut data = Bytes::new(env);
    push_32(env, &mut data, &previous_challenge.to_bytes());
    for i in 0..(log_n - 1) {
        push_point(env, &mut data, &proof.gemini_fold_comms[i]);
    }
    let next_previous_challenge = hash_to_fr(&data);
    let gemini_r = split_challenge(next_previous_challenge).0;
    (gemini_r, next_previous_challenge)
}

/// Generate shplonk_nu challenge.
/// Matches Solidity: hash(prev, geminiAEvaluations[0..logN])
fn generate_shplonk_nu_challenge(
    env: &Env, proof: &Proof, previous_challenge: Fr, log_n: usize,
) -> (Fr, Fr) {
    let mut data = Bytes::new(env);
    push_32(env, &mut data, &previous_challenge.to_bytes());
    for i in 0..log_n {
        push_32(env, &mut data, &proof.gemini_a_evaluations[i].to_bytes());
    }
    let next_previous_challenge = hash_to_fr(&data);
    let shplonk_nu = split_challenge(next_previous_challenge).0;
    (shplonk_nu, next_previous_challenge)
}

/// Generate shplonk_z challenge.
/// Matches Solidity: hash(prev, shplonkQ as raw x,y)
fn generate_shplonk_z_challenge(env: &Env, proof: &Proof, previous_challenge: Fr) -> (Fr, Fr) {
    let mut data = Bytes::new(env);
    push_32(env, &mut data, &previous_challenge.to_bytes());
    push_point(env, &mut data, &proof.shplonk_q);
    let next_previous_challenge = hash_to_fr(&data);
    let shplonk_z = split_challenge(next_previous_challenge).0;
    (shplonk_z, next_previous_challenge)
}

pub fn generate_transcript(
    env: &Env,
    proof: &Proof,
    public_inputs: &Bytes,
    vk_hash: &[u8; 32],
    circuit_size: u64,
    public_inputs_size: u64,
    _pub_inputs_offset: u64,
) -> Transcript {
    let log_n = {
        let mut n = circuit_size;
        let mut log = 0u64;
        while n > 1 {
            n >>= 1;
            log += 1;
        }
        log as usize
    };

    // 1) eta/beta/gamma
    let (rp, previous_challenge) =
        generate_relation_parameters_challenges(env, proof, public_inputs, vk_hash, public_inputs_size);

    // 2) alphas (powers of single alpha)
    let (alphas, previous_challenge) = generate_alpha_challenges(env, previous_challenge, proof);

    // 3) gate challenges (squaring pattern)
    let (gate_chals, previous_challenge) = generate_gate_challenges(env, previous_challenge);

    // 4) sumcheck challenges
    let (u_chals, previous_challenge) =
        generate_sumcheck_challenges(env, proof, previous_challenge, log_n);

    // 5) rho
    let (rho, previous_challenge) = generate_rho_challenge(env, proof, previous_challenge);

    // 6) gemini_r
    let (gemini_r, previous_challenge) =
        generate_gemini_r_challenge(env, proof, previous_challenge, log_n);

    // 7) shplonk_nu
    let (shplonk_nu, previous_challenge) =
        generate_shplonk_nu_challenge(env, proof, previous_challenge, log_n);

    // 8) shplonk_z
    let (shplonk_z, _previous_challenge) =
        generate_shplonk_z_challenge(env, proof, previous_challenge);

    Transcript {
        rel_params: rp,
        alphas,
        gate_challenges: gate_chals,
        sumcheck_u_challenges: u_chals,
        rho,
        gemini_r,
        shplonk_nu,
        shplonk_z,
    }
}

/// Generate relation parameters (eta, beta, gamma).
fn generate_relation_parameters_challenges(
    env: &Env,
    proof: &Proof,
    public_inputs: &Bytes,
    vk_hash: &[u8; 32],
    public_inputs_size: u64,
) -> (RelationParameters, Fr) {
    let (eta, eta_two, eta_three, previous_challenge) =
        generate_eta_challenge(env, proof, public_inputs, vk_hash, public_inputs_size);
    let (beta, gamma, next_previous_challenge) =
        generate_beta_and_gamma_challenges(env, previous_challenge, proof);
    let rp = RelationParameters {
        eta,
        eta_two,
        eta_three,
        beta,
        gamma,
        public_inputs_delta: Fr::zero(),
    };
    (rp, next_previous_challenge)
}
